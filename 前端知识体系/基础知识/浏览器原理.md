# 🌐 浏览器工作原理

> 从 URL 输入到页面展示，浏览器都做了什么？

---

## 📚 目录

1. [浏览器架构](#浏览器架构)
2. [从输入 URL 到页面渲染](#从输入-url-到页面渲染)
3. [渲染流程详解](#渲染流程详解)
4. [重绘与回流](#重绘与回流)
5. [事件循环机制](#事件循环机制)
6. [浏览器缓存](#浏览器缓存)
7. [性能优化](#性能优化)

---

## 浏览器架构

### 🏗️ 多进程架构

现代浏览器（Chrome）采用**多进程架构**：

```
Chrome 浏览器
│
├─ Browser 进程（主进程）
│  └─ 负责：地址栏、书签、前进后退、网络请求、文件访问等
│
├─ Renderer 进程（渲染进程）
│  └─ 负责：渲染页面，每个 Tab 一个进程
│
├─ GPU 进程
│  └─ 负责：3D 绘制、硬件加速
│
└─ Plugin 进程
   └─ 负责：插件运行（Flash、PDF 等）
```

### 🎯 为什么要多进程？

| 优点 | 说明 |
|:---:|:---|
| 🔒 **安全性** | 进程隔离，一个页面崩溃不影响其他页面 |
| 🚀 **稳定性** | 插件崩溃不会导致整个浏览器崩溃 |
| ⚡ **性能** | 多核 CPU 并行处理 |

---

## 从输入 URL 到页面渲染

### 🔄 完整流程（8 个步骤）

```
1. URL 解析
2. DNS 查询
3. 建立 TCP 连接
4. 发送 HTTP 请求
5. 服务器处理请求
6. 浏览器接收响应
7. 渲染页面
8. JS 执行
```

---

### 1️⃣ URL 解析

```
输入：https://www.example.com/path?query=1#hash

解析：
├─ 协议: https
├─ 域名: www.example.com
├─ 端口: 443（HTTPS 默认）
├─ 路径: /path
├─ 查询: ?query=1
└─ 锚点: #hash
```

---

### 2️⃣ DNS 查询

**DNS（Domain Name System）**：把域名转换为 IP 地址

```
www.example.com → 192.168.1.1

查询过程：
1. 浏览器缓存
2. 操作系统缓存
3. 路由器缓存
4. ISP DNS 服务器
5. 根域名服务器
6. 顶级域名服务器 (.com)
7. 权威域名服务器 (example.com)
```

#### 优化：DNS 预解析

```html
<!-- 提前解析域名 -->
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
```

---

### 3️⃣ 建立 TCP 连接

**TCP 三次握手**：

```
客户端                      服务器
  |                           |
  |----SYN (请求连接)--------->|
  |                           |
  |<---SYN-ACK (同意连接)------|
  |                           |
  |----ACK (确认连接)--------->|
  |                           |
  |========连接建立============|
```

#### HTTPS 还需要 TLS 握手

```
1. 客户端：你好，我支持的加密算法有...
2. 服务器：好的，我们用 RSA 算法，这是我的证书
3. 客户端：验证证书 OK，我们用这个密钥
4. 服务器：收到，开始加密通信
```

---

### 4️⃣ 发送 HTTP 请求

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0...
Accept: text/html,application/json
Accept-Encoding: gzip, deflate
Connection: keep-alive
```

---

### 5️⃣ 服务器处理请求

```
1. 服务器接收请求
2. 路由匹配
3. 业务逻辑处理
4. 查询数据库
5. 渲染页面（SSR）或返回数据（API）
6. 返回响应
```

---

### 6️⃣ 浏览器接收响应

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Cache-Control: max-age=3600
Content-Length: 12345

<!DOCTYPE html>
<html>...
```

---

### 7️⃣ 渲染页面 ⭐

**这是最关键的一步！** 详见下一节。

---

## 渲染流程详解

### 🎨 渲染流水线（5 个步骤）

```
1. 解析 HTML → DOM Tree
2. 解析 CSS  → CSSOM Tree
3. 合并       → Render Tree
4. 布局       → Layout
5. 绘制       → Paint
```

---

### 1️⃣ 构建 DOM Tree

**解析 HTML，构建 DOM 树**：

```html
<html>
  <body>
    <div class="container">
      <h1>Hello</h1>
      <p>World</p>
    </div>
  </body>
</html>
```

```
DOM Tree:
html
└─ body
   └─ div.container
      ├─ h1 ("Hello")
      └─ p ("World")
```

---

### 2️⃣ 构建 CSSOM Tree

**解析 CSS，构建样式树**：

```css
.container {
  width: 1200px;
  margin: 0 auto;
}
h1 {
  color: red;
  font-size: 24px;
}
```

```
CSSOM Tree:
.container { width: 1200px; margin: 0 auto; }
h1 { color: red; font-size: 24px; }
```

---

### 3️⃣ 构建 Render Tree

**合并 DOM 和 CSSOM，生成渲染树**：

- 只包含**可见元素**
- `display: none` 的元素不在渲染树中
- `visibility: hidden` 的元素**在**渲染树中

```
Render Tree:
div.container (width: 1200px)
├─ h1 (color: red, font-size: 24px)
└─ p
```

---

### 4️⃣ 布局 (Layout / Reflow)

**计算每个节点的精确位置和大小**：

```
div.container
├─ x: 100px, y: 0px
├─ width: 1200px, height: 500px

h1
├─ x: 100px, y: 0px
├─ width: 1200px, height: 50px

p
├─ x: 100px, y: 50px
├─ width: 1200px, height: 30px
```

---

### 5️⃣ 绘制 (Paint)

**把渲染树绘制到屏幕上**：

```
1. 绘制背景色
2. 绘制边框
3. 绘制文字
4. 绘制阴影
```

---

### ⚡ 渲染优化：分层与合成

现代浏览器会把页面分成多个**图层（Layer）**：

```
图层 1: 背景
图层 2: 普通内容
图层 3: fixed 定位元素
图层 4: transform 元素
图层 5: video 元素
```

**合成（Composite）**：GPU 把多个图层合成最终画面

---

### 🎯 哪些属性会创建新图层？

```css
/* 会创建新图层 */
.layer {
  transform: translateZ(0);      /* 3D 变换 */
  will-change: transform;        /* 提示浏览器 */
  position: fixed;               /* 固定定位 */
  opacity: 0.5;                  /* 透明度动画 */
}
```

**好处**：图层单独绘制，不影响其他内容，性能更好！

---

## 重绘与回流

### 🎨 重绘 (Repaint)

**定义**：元素外观改变，但布局不变，重新绘制元素。

**触发条件**：

```css
/* 这些属性改变会触发重绘 */
color: red;
background-color: blue;
visibility: hidden;
outline: 1px solid red;
box-shadow: 0 0 10px red;
```

**性能影响**：⚠️ 中等（跳过布局，只重新绘制）

---

### 📐 回流 (Reflow / Layout)

**定义**：元素的尺寸、位置改变，重新计算布局。

**触发条件**：

```javascript
// 1. 修改几何属性
element.style.width = '100px'
element.style.height = '200px'
element.style.padding = '10px'
element.style.margin = '20px'

// 2. 读取布局属性（强制同步布局）
const width = element.offsetWidth
const height = element.clientHeight
const rect = element.getBoundingClientRect()

// 3. 修改 DOM 结构
element.appendChild(newNode)
element.remove()

// 4. 改变窗口大小
window.resize()
```

**性能影响**：❌ 严重（需要重新计算布局 + 重新绘制）

---

### ⚡ 回流一定触发重绘，重绘不一定触发回流

```
回流 (Reflow)
  └─ 重新计算布局
  └─ 重新绘制 ✓

重绘 (Repaint)
  └─ 重新绘制 ✓
```

---

### 🚀 优化：减少回流和重绘

#### ❌ 坏的做法：

```javascript
// 每次修改都触发回流
element.style.width = '100px'    // 回流 1
element.style.height = '200px'   // 回流 2
element.style.margin = '10px'    // 回流 3
```

#### ✅ 好的做法：

```javascript
// 方法 1：一次性修改
element.style.cssText = 'width: 100px; height: 200px; margin: 10px'

// 方法 2：修改 class
element.className = 'new-style'

// 方法 3：批量操作前先隐藏
element.style.display = 'none'
// 进行 100 次修改...
element.style.display = 'block'  // 只触发 1 次回流

// 方法 4：使用 DocumentFragment
const fragment = document.createDocumentFragment()
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li')
  fragment.appendChild(li)
}
ul.appendChild(fragment)  // 只触发 1 次回流
```

---

### 🎯 使用 transform 代替 top/left

```css
/* ❌ 触发回流 */
.box {
  position: absolute;
  left: 100px;  /* 改变 left 会回流 */
}

/* ✅ 只触发合成，不回流不重绘 */
.box {
  transform: translateX(100px);  /* GPU 加速 */
}
```

---

## 事件循环机制

### 🔄 JavaScript 单线程模型

JavaScript 是**单线程**的，通过**事件循环（Event Loop）**实现异步。

```
调用栈 (Call Stack)
  ↓
同步代码执行
  ↓
遇到异步任务？
  ├─ 是 → 放入任务队列
  └─ 否 → 继续执行
  ↓
调用栈清空？
  ├─ 是 → 从任务队列取任务执行
  └─ 否 → 继续执行
```

---

### 📋 宏任务与微任务

```
宏任务 (Macro Task):
├─ script (整体代码)
├─ setTimeout / setInterval
├─ I/O 操作
├─ UI rendering
└─ setImmediate (Node.js)

微任务 (Micro Task):
├─ Promise.then/catch/finally
├─ MutationObserver
├─ process.nextTick (Node.js)
└─ queueMicrotask
```

---

### ⚡ 执行顺序

```
1. 执行一个宏任务（script）
2. 执行所有微任务
3. 渲染 UI（如果需要）
4. 执行下一个宏任务
5. 重复...
```

---

### 🎯 经典面试题

```javascript
console.log('1')

setTimeout(() => {
  console.log('2')
}, 0)

Promise.resolve().then(() => {
  console.log('3')
})

console.log('4')

// 输出顺序：1 → 4 → 3 → 2
```

**解析**：

```
1. console.log('1')          → 输出 1
2. setTimeout 放入宏任务队列   → [setTimeout]
3. Promise.then 放入微任务队列 → [Promise]
4. console.log('4')          → 输出 4
5. 执行微任务队列              → 输出 3
6. 执行下一个宏任务            → 输出 2
```

---

## 浏览器缓存

### 📦 缓存类型

```
浏览器缓存
│
├─ 强缓存
│  ├─ Expires (HTTP/1.0)
│  └─ Cache-Control (HTTP/1.1)
│
└─ 协商缓存
   ├─ Last-Modified / If-Modified-Since
   └─ ETag / If-None-Match
```

---

### 1️⃣ 强缓存

**不发请求，直接使用缓存**：

```http
# 响应头
Cache-Control: max-age=3600  # 缓存 1 小时
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

**优先级**：`Cache-Control` > `Expires`

---

### 2️⃣ 协商缓存

**发请求，服务器判断是否使用缓存**：

```http
# 首次请求响应
Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT
ETag: "abc123"

# 再次请求
If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT
If-None-Match: "abc123"

# 服务器响应
304 Not Modified  # 使用缓存
```

---

### 🎯 缓存策略

| 资源类型 | 缓存策略 |
|:---:|:---|
| **HTML** | 协商缓存 or no-cache |
| **CSS/JS（带 hash）** | 强缓存 1 年 |
| **图片** | 强缓存 1 个月 |
| **API 数据** | 协商缓存 or no-cache |

---

## 性能优化

### ⚡ 关键指标

```
FP  (First Paint)              首次绘制
FCP (First Contentful Paint)   首次内容绘制
LCP (Largest Contentful Paint) 最大内容绘制
TTI (Time to Interactive)      可交互时间
FID (First Input Delay)        首次输入延迟
CLS (Cumulative Layout Shift)  累积布局偏移
```

---

### 🚀 优化技巧

#### 1. 减少回流重绘

```javascript
// 使用 transform 代替 top/left
element.style.transform = 'translateX(100px)'

// 批量操作 DOM
requestAnimationFrame(() => {
  // DOM 操作
})
```

---

#### 2. 防抖与节流

```javascript
// 防抖：延迟执行
function debounce(fn, delay) {
  let timer = null
  return function(...args) {
    clearTimeout(timer)
    timer = setTimeout(() => fn.apply(this, args), delay)
  }
}

// 节流：定期执行
function throttle(fn, delay) {
  let last = 0
  return function(...args) {
    const now = Date.now()
    if (now - last > delay) {
      last = now
      fn.apply(this, args)
    }
  }
}
```

---

#### 3. 懒加载

```javascript
// 图片懒加载
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target
      img.src = img.dataset.src
      observer.unobserve(img)
    }
  })
})

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img)
})
```

---

## 📚 学习资源

- 📖 [浏览器工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)
- 📖 [图解浏览器](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- 🎬 [浏览器渲染原理](https://www.bilibili.com/video/BV1x54y1B7RE)

---

## ✅ 学习检查清单

- [ ] 理解浏览器多进程架构
- [ ] 掌握从 URL 到页面渲染的完整流程
- [ ] 理解渲染流水线
- [ ] 区分重绘和回流
- [ ] 掌握事件循环机制
- [ ] 理解浏览器缓存策略
- [ ] 能进行性能优化

---

**理解浏览器，写出更高性能的代码！** 🚀

