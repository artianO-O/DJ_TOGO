# Vue3 核心原理面试题总结

> 高频面试题及详细解答

---

## 📌 响应式原理

### Q1：Vue3 的响应式原理是什么？

**答**：Vue3 使用 **Proxy** 实现响应式，核心流程：

1. **创建响应式**：`reactive()` 用 Proxy 包装对象
2. **依赖收集**：读取数据时（get），把当前 effect 收集到依赖中
3. **触发更新**：修改数据时（set），通知所有依赖重新执行

```javascript
const state = reactive({ count: 0 })

effect(() => {
  console.log(state.count)  // 读取触发 track，收集这个 effect
})

state.count++  // 修改触发 trigger，执行收集到的 effect
```

---

### Q2：Vue3 为什么用 Proxy 代替 Object.defineProperty？

**答**：

| 对比 | Object.defineProperty | Proxy |
|-----|----------------------|-------|
| 监听新增属性 | ❌ 需要 Vue.set | ✅ 自动监听 |
| 监听数组索引 | ❌ 无法监听 | ✅ 自动监听 |
| 监听数组长度 | ❌ 无法监听 | ✅ 自动监听 |
| 性能 | 需要递归遍历 | 懒代理，按需响应 |
| 删除属性 | ❌ 需要 Vue.delete | ✅ 自动监听 |

**代码对比**：

```javascript
// Vue2：新增属性无法监听
data.newProp = 123  // 不触发更新
Vue.set(data, 'newProp', 123)  // 需要这样

// Vue3：直接就能监听
state.newProp = 123  // 正常触发更新
```

---

### Q3：ref 和 reactive 的区别？

**答**：

| 特性 | ref | reactive |
|-----|-----|----------|
| 支持类型 | 任意类型 | 只支持对象 |
| 访问方式 | `.value` | 直接访问 |
| 整体替换 | ✅ 可以 | ❌ 会断开响应式 |
| 解构 | 保持响应式 | 丢失响应式 |

**核心原理**：
- `reactive` 直接用 Proxy 包装对象
- `ref` 把值包装成 `{ value: xxx }` 对象，再用 getter/setter 拦截

```javascript
// ref 简化实现
function ref(value) {
  return {
    get value() {
      track(this, 'value')
      return value
    },
    set value(newVal) {
      value = newVal
      trigger(this, 'value')
    }
  }
}
```

---

### Q4：computed 的缓存原理？

**答**：computed 通过 **dirty 标志** 实现缓存：

1. 首次访问：执行计算，缓存结果，`dirty = false`
2. 再次访问：直接返回缓存
3. 依赖变化：`dirty = true`（通过 scheduler）
4. 下次访问：重新计算

```javascript
function computed(getter) {
  let value
  let dirty = true
  
  const effect = new ReactiveEffect(getter, () => {
    dirty = true  // 依赖变化时，标记为脏
  })
  
  return {
    get value() {
      if (dirty) {
        value = effect.run()
        dirty = false
      }
      return value
    }
  }
}
```

---

## 📌 虚拟 DOM 与 Diff

### Q5：什么是虚拟 DOM？有什么优点？

**答**：

**虚拟 DOM** = 用 JavaScript 对象描述 DOM 结构

**优点**：
1. **跨平台**：可渲染到 DOM、Canvas、Native
2. **性能优化**：批量更新，最小化 DOM 操作
3. **声明式**：只描述结果，框架处理过程

**注意**：虚拟 DOM **不是绝对更快**，首次渲染比直接操作 DOM 慢。它的价值在于：**合理的性能 + 更好的开发体验**。

---

### Q6：Vue3 的 Diff 算法流程？

**答**：Vue3 采用**快速 Diff 算法**，分 5 步：

1. **同步头部节点**：从头比较相同的节点
2. **同步尾部节点**：从尾比较相同的节点
3. **新增节点**：如果只剩新节点，全部挂载
4. **删除节点**：如果只剩旧节点，全部卸载
5. **处理中间乱序**：使用**最长递增子序列**优化移动

```
旧: A B C D E F G
新: A B E C D H F G

1. 头部同步：A B
2. 尾部同步：F G
3. 中间处理：C D E → E C D H
```

---

### Q7：为什么 v-for 需要 key？

**答**：

**key 的作用**：帮助 Diff 算法识别节点，判断是否可复用。

**没有 key**：
- Vue 使用"就地更新"策略
- 只对比同位置的节点
- 可能导致状态错乱

**有 key**：
- 通过 key 精确匹配同一个节点
- 可以最小化 DOM 操作
- 保持组件状态

```vue
<!-- ❌ 用 index 作为 key -->
<li v-for="(item, index) in list" :key="index">

<!-- ✅ 用唯一标识作为 key -->
<li v-for="item in list" :key="item.id">
```

**用 index 的问题**：删除/添加元素后，index 会变，导致错误复用。

---

## 📌 组件相关

### Q8：Vue3 组件的渲染流程？

**答**：

```
1. createApp(App)         创建应用实例
       ↓
2. app.mount('#app')      挂载应用
       ↓
3. createVNode()          创建组件 VNode
       ↓
4. mountComponent()       挂载组件
   - createComponentInstance()  创建实例
   - setupComponent()           执行 setup
   - setupRenderEffect()        创建渲染 effect
       ↓
5. render() + patch()     渲染 VNode → DOM
```

---

### Q9：setup 函数的作用？执行时机？

**答**：

**作用**：
- 替代 Options API（data、computed、methods）
- 组织组件逻辑
- 返回响应式数据和方法

**执行时机**：
- 在 `beforeCreate` 和 `created` 之间
- 此时组件实例已创建，但还未挂载

**注意**：
- setup 中没有 `this`
- 通过参数获取 props 和 context

```javascript
setup(props, { attrs, slots, emit }) {
  // props 是响应式的
  // attrs、slots 是非响应式的
}
```

---

### Q10：Vue3 生命周期钩子有哪些？

**答**：

| Options API | Composition API | 时机 |
|------------|-----------------|------|
| beforeCreate | setup | 实例创建前 |
| created | setup | 实例创建后 |
| beforeMount | onBeforeMount | 挂载前 |
| mounted | onMounted | 挂载后 |
| beforeUpdate | onBeforeUpdate | 更新前 |
| updated | onUpdated | 更新后 |
| beforeUnmount | onBeforeUnmount | 卸载前 |
| unmounted | onUnmounted | 卸载后 |

**新增**：
- `onActivated` / `onDeactivated` - keep-alive
- `onErrorCaptured` - 错误捕获

---

## 📌 编译优化

### Q11：Vue3 有哪些编译时优化？

**答**：

**1. 静态提升 (Static Hoisting)**
```javascript
// 静态节点提升到 render 外，只创建一次
const _hoisted_1 = h('p', null, '静态文本')
```

**2. 补丁标志 (Patch Flags)**
```javascript
// 标记动态内容类型
h('div', { id: dynamicId }, text, 1 | 2, ['id'])
// 1 = TEXT, 2 = PROPS
```

**3. Block Tree**
- 收集所有动态子孙节点
- Diff 时跳过静态节点

**4. 事件缓存**
```javascript
// 事件处理函数缓存，避免重复创建
onClick: _cache[0] || (_cache[0] = () => handleClick())
```

---

### Q12：Vue3 的 Tree-shaking 是怎么实现的？

**答**：

**原理**：ES Module 静态分析 + 按需引入

```javascript
// Vue3：按需引入
import { ref, computed, watch } from 'vue'

// Vue2：全量引入
import Vue from 'vue'
```

**为什么 Vue3 可以**：
- 使用 ES Module 的 `export` 导出单独的函数
- 构建工具可以静态分析，剔除未使用的代码
- `/*#__PURE__*/` 注释标记纯函数，方便 tree-shaking

---

## 📌 高级特性

### Q13：nextTick 的原理？

**答**：

Vue 的更新是**异步批量**的：

```javascript
count.value = 1
count.value = 2
count.value = 3
// 只触发一次更新
```

**nextTick** 等待 DOM 更新完成：

```javascript
count.value = 100

// DOM 还没更新
console.log(el.textContent)  // 旧值

await nextTick()

// DOM 已更新
console.log(el.textContent)  // 100
```

**原理**：基于 `Promise.resolve().then()`

```javascript
function nextTick(fn) {
  return fn ? Promise.resolve().then(fn) : Promise.resolve()
}
```

---

### Q14：keep-alive 的原理？

**答**：

**作用**：缓存组件实例，避免重复创建

**原理**：
1. 维护一个缓存对象 `cache`
2. 组件卸载时，不销毁，存入缓存
3. 组件激活时，从缓存取出，直接挂载

```javascript
// 简化实现
setup() {
  const cache = new Map()
  
  return () => {
    const vnode = slots.default()
    const key = vnode.key
    
    if (cache.has(key)) {
      // 从缓存恢复
      vnode.component = cache.get(key)
    } else {
      // 加入缓存
      cache.set(key, vnode.component)
    }
    
    return vnode
  }
}
```

**LRU 缓存**：当缓存满时，删除最久未使用的组件

---

### Q15：Teleport 的原理？

**答**：

**作用**：把组件内容渲染到指定 DOM 位置

```vue
<Teleport to="body">
  <div class="modal">Modal 内容</div>
</Teleport>
```

**原理**：
1. 编译时识别 `<Teleport>`，生成特殊 VNode
2. 渲染时，找到 `to` 指定的容器
3. 把子内容渲染到目标容器，而不是当前位置

```javascript
function mountTeleport(vnode, container) {
  const target = document.querySelector(vnode.props.to)
  // 渲染到目标容器
  patch(null, vnode.children, target)
}
```

---

## 📌 性能优化

### Q16：Vue3 性能优化方案有哪些？

**答**：

**编译时优化**：
- 静态提升
- 补丁标志
- 事件缓存
- Block Tree

**运行时优化**：
- 响应式按需代理（懒代理）
- Diff 算法优化（最长递增子序列）

**开发者优化**：
- `v-once`：只渲染一次
- `v-memo`：记忆子树
- `shallowRef/shallowReactive`：浅层响应式
- 虚拟列表：大数据渲染
- 异步组件：按需加载

```vue
<!-- v-memo：当 item.id 不变时，跳过更新 -->
<div v-for="item in list" :key="item.id" v-memo="[item.id]">
  {{ item.name }}
</div>
```

---

## 📌 其他高频问题

### Q17：Vue3 和 Vue2 的主要区别？

**答**：

| 方面 | Vue2 | Vue3 |
|-----|------|------|
| 响应式 | Object.defineProperty | Proxy |
| API 风格 | Options API | Composition API |
| TypeScript | 支持差 | 原生支持 |
| 性能 | 一般 | 更快（编译优化） |
| Tree-shaking | 不支持 | 支持 |
| Fragment | 不支持 | 支持多根节点 |
| Teleport | 无 | 支持 |
| Suspense | 无 | 支持 |

---

### Q18：Composition API 的优势？

**答**：

1. **逻辑复用**：使用 composables 函数，比 mixins 更清晰
2. **代码组织**：相关逻辑放一起，而不是分散在 data/methods/computed
3. **类型推断**：更好的 TypeScript 支持
4. **打包体积**：更好的 tree-shaking

```javascript
// 逻辑复用示例
function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  return { count, increment }
}

// 在组件中使用
setup() {
  const { count, increment } = useCounter()
  return { count, increment }
}
```

---

## 🎯 面试技巧

1. **先答概念，再说原理**
2. **能画图就画图**
3. **结合源码/代码示例**
4. **说出 Vue2 和 Vue3 的对比**
5. **提及实际项目经验**

---

## 📚 推荐阅读

1. [Vue3 官方文档](https://cn.vuejs.org/)
2. [Vue3 源码解读](https://github.com/vuejs/core)
3. 《Vue.js 设计与实现》- 霍春阳
4. [Vue Mastery 课程](https://www.vuemastery.com/)



